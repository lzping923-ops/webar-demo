<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OpenWay WebAR Prototype</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family: system-ui; }

    /* Fallback camera (getUserMedia) */
    #cam2d {
      position:fixed; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      display:none;
    }

    /* Simple UI */
    #btn {
      position:fixed; left:50%; bottom:56px; transform:translateX(-50%);
      padding:12px 16px; border-radius:12px; border:0;
      font:14px system-ui; z-index:30;
    }
    #msg {
      position:fixed; left:0; right:0; bottom:14px;
      text-align:center; color:#fff; font:13px system-ui;
      opacity:.85; z-index:20; pointer-events:none;
      padding:0 14px;
    }

    /* 2D overlay (fallback mode) */
    #ui2d { position:fixed; inset:0; pointer-events:none; z-index:15; display:none; }
    .el { position:absolute; user-select:none; -webkit-user-drag:none; }

    /* tweak positions for your design */
    #pathOk2d { left:50%; top:56%; transform:translateX(-50%); width:min(88vw,560px); opacity:.75; }
    #dots2d   { left:50%; top:58%; transform:translateX(-50%); width:min(60vw,420px); opacity:.95; }
  </style>
</head>
<body>
  <button id="btn">Start</button>
  <div id="msg">Starting…</div>

  <!-- Fallback camera layer -->
  <video id="cam2d" autoplay playsinline muted></video>

  <!-- Fallback 2D overlay -->
  <div id="ui2d">
    <img id="pathOk2d" class="el" src="path_ok.png" alt="Path highlight">
    <img id="dots2d" class="el" src="dots.png" alt="Dots">
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const btn = document.getElementById("btn");
    const msg = document.getElementById("msg");
    const cam2d = document.getElementById("cam2d");
    const ui2d = document.getElementById("ui2d");

    // ---------- Fallback: normal camera + 2D overlay ----------
    async function startFallback2D() {
      msg.textContent = "Fallback mode: camera + overlay (tap to toggle if you want).";
      cam2d.style.display = "block";
      ui2d.style.display = "block";
      btn.style.display = "none";

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" } },
          audio: false
        });
        cam2d.srcObject = stream;
      } catch (e) {
        alert("Camera permission is required. Please allow camera access and try again.");
      }
    }

    // ---------- WebXR AR (true plane hit-test) ----------
    let renderer, scene, camera;
    let xrSession, refSpace, viewerSpace, hitTestSource;
    let reticle, pathGroup, placedOnce = false;

    function makeReticle() {
      const geo = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0.9 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.visible = false;
      mesh.matrixAutoUpdate = false;
      return mesh;
    }

    async function loadTexture(url) {
      return await new Promise((resolve, reject) => {
        new THREE.TextureLoader().load(url, (tex) => resolve(tex), undefined, reject);
      });
    }

    async function makePathGroup() {
      const pathTex = await loadTexture("path_ok.png");
      const dotsTex = await loadTexture("dots.png");
      pathTex.colorSpace = THREE.SRGBColorSpace;
      dotsTex.colorSpace = THREE.SRGBColorSpace;

      // You asked not to change PNG sizes — so we keep the plane SMALL to stay sharp.
      const W = 0.6;  // meters
      const L = 1.0;  // meters

      const group = new THREE.Group();

      const pathMat = new THREE.MeshBasicMaterial({ map: pathTex, transparent:true, opacity:0.85 });
      const pathGeo = new THREE.PlaneGeometry(W, L);
      const pathMesh = new THREE.Mesh(pathGeo, pathMat);
      pathMesh.rotation.x = -Math.PI / 2;
      group.add(pathMesh);

      const dotsMat = new THREE.MeshBasicMaterial({ map: dotsTex, transparent:true, opacity:0.95 });
      const dotsGeo = new THREE.PlaneGeometry(W, L);
      const dotsMesh = new THREE.Mesh(dotsGeo, dotsMat);
      dotsMesh.position.y = 0.002;
      dotsMesh.rotation.x = -Math.PI / 2;
      group.add(dotsMesh);

      return group;
    }

    async function startWebXRAR() {
      if (!navigator.xr) return false;

      const supported = await navigator.xr.isSessionSupported("immersive-ar").catch(() => false);
      if (!supported) return false;

      msg.textContent = "WebXR AR: move phone to detect floor, then tap to place the path.";

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      reticle = makeReticle();
      scene.add(reticle);

      xrSession = await navigator.xr.requestSession("immersive-ar", {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
      });

      renderer.xr.setSession(xrSession);

      refSpace = await xrSession.requestReferenceSpace("local");
      viewerSpace = await xrSession.requestReferenceSpace("viewer");
      hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

      pathGroup = await makePathGroup();

      btn.style.display = "none";

      xrSession.addEventListener("select", () => {
        if (!reticle.visible) return;

        if (!placedOnce) {
          scene.add(pathGroup);
          placedOnce = true;
        }
        pathGroup.position.setFromMatrixPosition(reticle.matrix);
        pathGroup.rotation.set(-Math.PI / 2, 0, 0);

        msg.textContent = "Placed! Tap again to reposition.";
      });

      xrSession.addEventListener("end", () => {
        placedOnce = false;
        msg.textContent = "AR ended.";
        btn.style.display = "";
      });

      renderer.setAnimationLoop((t, frame) => {
        if (frame) {
          const hits = frame.getHitTestResults(hitTestSource);
          if (hits.length > 0) {
            const pose = hits[0].getPose(refSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
        renderer.render(scene, camera);
      });

      return true;
    }

    // ---------- Start button ----------
    btn.addEventListener("click", async () => {
      msg.textContent = "Trying WebXR AR…";
      const ok = await startWebXRAR();
      if (!ok) {
        // If WebXR AR isn't supported, guarantee camera opens
        await startFallback2D();
      }
    });

    // Initial text
    msg.textContent = "Tap Start. If WebXR AR isn't supported, it will open normal camera automatically.";
  </script>
</body>
</html>



