<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OpenWay WebXR Plane Demo</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #msg{
      position:fixed; left:0; right:0; bottom:14px;
      text-align:center; color:#fff; font:13px system-ui;
      opacity:.8; z-index:10; pointer-events:none;
    }
    #btn{
      position:fixed; left:50%; bottom:56px; transform:translateX(-50%);
      padding:12px 16px; border-radius:12px; border:0;
      font:14px system-ui; z-index:20;
    }
  </style>
</head>
<body>
  <button id="btn">Start AR</button>
  <div id="msg">Tip: Move phone to detect the floor, then tap to place path.</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const btn = document.getElementById("btn");
    const msg = document.getElementById("msg");

    let renderer, scene, camera;
    let xrSession, refSpace, viewerSpace, hitTestSource;
    let reticle;
    let placed = false;

    // Create a "reticle" to show where the floor hit is
    function makeReticle() {
      const geo = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0.9 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.visible = false;
      return mesh;
    }

    // Create a plane with your path texture + dots texture
    async function makePathPlane() {
      const loader = new THREE.TextureLoader();

      const [pathTex, dotsTex] = await Promise.all([
        new Promise((res, rej) => loader.load("path_ok.png", res, undefined, rej)),
        new Promise((res, rej) => loader.load("dots.png", res, undefined, rej)),
      ]);

      // Keep textures crisp-ish
      pathTex.colorSpace = THREE.SRGBColorSpace;
      dotsTex.colorSpace = THREE.SRGBColorSpace;

      // Two layers: path + dots (as separate planes)
      const group = new THREE.Group();

      // Path
      const pathMat = new THREE.MeshBasicMaterial({
        map: pathTex,
        transparent: true,
        opacity: 0.85
      });
      // Size in meters (tweak): width 1.2m, length 2.2m
      const pathGeo = new THREE.PlaneGeometry(1.2, 2.2);
      const pathMesh = new THREE.Mesh(pathGeo, pathMat);
      pathMesh.rotation.x = -Math.PI / 2;
      group.add(pathMesh);

      // Dots (slightly above to avoid z-fighting)
      const dotsMat = new THREE.MeshBasicMaterial({
        map: dotsTex,
        transparent: true,
        opacity: 0.95
      });
      const dotsGeo = new THREE.PlaneGeometry(1.2, 2.2);
      const dotsMesh = new THREE.Mesh(dotsGeo, dotsMat);
      dotsMesh.position.y = 0.002; // 2mm above
      dotsMesh.rotation.x = -Math.PI / 2;
      group.add(dotsMesh);

      return group;
    }

    async function startAR() {
      if (!navigator.xr) {
        alert("WebXR not supported on this browser/device. Please use Android Chrome.");
        return;
      }

      // Check immersive-ar support
      const supported = await navigator.xr.isSessionSupported("immersive-ar");
      if (!supported) {
        alert("immersive-ar not supported. Please use Android Chrome with ARCore.");
        return;
      }

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      // Reticle
      reticle = makeReticle();
      scene.add(reticle);

      // Start session
      xrSession = await navigator.xr.requestSession("immersive-ar", {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
      });

      renderer.xr.setSession(xrSession);

      refSpace = await xrSession.requestReferenceSpace("local");
      viewerSpace = await xrSession.requestReferenceSpace("viewer");
      hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

      btn.style.display = "none";
      msg.textContent = "Move phone to detect the floor. Tap to place the path.";

      const pathGroup = await makePathPlane(); // load textures once

      // Tap to place (first tap places; next taps can reposition if you want)
      xrSession.addEventListener("select", () => {
        if (!reticle.visible) return;
        if (!placed) {
          scene.add(pathGroup);
          placed = true;
        }
        pathGroup.position.setFromMatrixPosition(reticle.matrix);
        pathGroup.quaternion.setFromRotationMatrix(reticle.matrix);
        // Keep it flat on the floor
        pathGroup.rotation.x = -Math.PI / 2;
        msg.textContent = "Placed! Tap again to reposition.";
      });

      xrSession.addEventListener("end", () => {
        placed = false;
        btn.style.display = "";
        msg.textContent = "AR ended.";
      });

      renderer.setAnimationLoop((t, frame) => {
        if (frame) {
          const hits = frame.getHitTestResults(hitTestSource);
          if (hits.length > 0) {
            const pose = hits[0].getPose(refSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
        renderer.render(scene, camera);
      });
    }

    btn.addEventListener("click", startAR);
  </script>
</body>
</html>



